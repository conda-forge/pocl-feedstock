From a5547f68ccbfbf162656686a322b3682f6943502 Mon Sep 17 00:00:00 2001
From: Isuru Fernando <isuruf@gmail.com>
Date: Fri, 29 May 2020 11:29:48 -0500
Subject: [PATCH 1/2] Fix kernels with automatic locals and function arguments

Previously autolocal_offset was not persisted to disk and therefore
kernels failed with an invalid memory access error when the cache was
used.
---
 lib/CL/devices/cuda/pocl-cuda-types.h | 79 ---------------------------
 lib/CL/devices/cuda/pocl-cuda.c       | 56 ++++++++++++++++++-
 lib/CL/devices/cuda/pocl-ptx-gen.cc   | 26 ++++-----
 lib/CL/devices/cuda/pocl-ptx-gen.h    |  3 +-
 lib/CL/pocl_binary.c                  | 16 +++++-
 lib/CL/pocl_cl.h                      |  1 +
 lib/CL/pocl_llvm_metadata.cc          |  4 ++
 7 files changed, 85 insertions(+), 100 deletions(-)
 delete mode 100644 lib/CL/devices/cuda/pocl-cuda-types.h

diff --git a/lib/CL/devices/cuda/pocl-cuda-types.h b/lib/CL/devices/cuda/pocl-cuda-types.h
deleted file mode 100644
index 30237fb22..000000000
--- a/lib/CL/devices/cuda/pocl-cuda-types.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* pocl-cuda.c - driver for CUDA devices
-
-   Copyright (c) 2016-2017 James Price / University of Bristol
-
-   Permission is hereby granted, free of charge, to any person obtaining a copy
-   of this software and associated documentation files (the "Software"), to
-   deal
-   in the Software without restriction, including without limitation the rights
-   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-   copies of the Software, and to permit persons to whom the Software is
-   furnished to do so, subject to the following conditions:
-
-   The above copyright notice and this permission notice shall be included in
-   all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-   FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-   THE SOFTWARE.
-*/
-
-#include "config.h"
-
-#include "common.h"
-#include "pocl.h"
-#include "pocl_util.h"
-
-#include <cuda.h>
-
-#ifndef PATH_MAX
-#define PATH_MAX 4096
-#endif
-
-typedef struct pocl_cuda_device_data_s
-{
-  CUdevice device;
-  CUcontext context;
-  CUevent epoch_event;
-  cl_ulong epoch;
-  char libdevice[PATH_MAX];
-  pocl_lock_t compile_lock;
-} pocl_cuda_device_data_t;
-
-typedef struct pocl_cuda_queue_data_s
-{
-  CUstream stream;
-  int use_threads;
-  pthread_t submit_thread;
-  pthread_t finalize_thread;
-  pthread_mutex_t lock;
-  pthread_cond_t pending_cond;
-  pthread_cond_t running_cond;
-  _cl_command_node *volatile pending_queue;
-  _cl_command_node *volatile running_queue;
-  cl_command_queue queue;
-} pocl_cuda_queue_data_t;
-
-typedef struct pocl_cuda_kernel_data_s
-{
-  CUmodule module;
-  CUmodule module_offsets;
-  CUfunction kernel;
-  CUfunction kernel_offsets;
-  size_t *alignments;
-  size_t auto_local_offset;
-} pocl_cuda_kernel_data_t;
-
-typedef struct pocl_cuda_event_data_s
-{
-  CUevent start;
-  CUevent end;
-  volatile int events_ready;
-  cl_int *ext_event_flag;
-  volatile unsigned num_ext_events;
-} pocl_cuda_event_data_t;
diff --git a/lib/CL/devices/cuda/pocl-cuda.c b/lib/CL/devices/cuda/pocl-cuda.c
index ac5953487..8c1a7477f 100644
--- a/lib/CL/devices/cuda/pocl-cuda.c
+++ b/lib/CL/devices/cuda/pocl-cuda.c
@@ -42,6 +42,48 @@
 
 #include <cuda.h>
 
+typedef struct pocl_cuda_device_data_s
+{
+  CUdevice device;
+  CUcontext context;
+  CUevent epoch_event;
+  cl_ulong epoch;
+  char libdevice[PATH_MAX];
+  pocl_lock_t compile_lock;
+} pocl_cuda_device_data_t;
+
+typedef struct pocl_cuda_queue_data_s
+{
+  CUstream stream;
+  int use_threads;
+  pthread_t submit_thread;
+  pthread_t finalize_thread;
+  pthread_mutex_t lock;
+  pthread_cond_t pending_cond;
+  pthread_cond_t running_cond;
+  _cl_command_node *volatile pending_queue;
+  _cl_command_node *volatile running_queue;
+  cl_command_queue queue;
+} pocl_cuda_queue_data_t;
+
+typedef struct pocl_cuda_kernel_data_s
+{
+  CUmodule module;
+  CUmodule module_offsets;
+  CUfunction kernel;
+  CUfunction kernel_offsets;
+  size_t *alignments;
+} pocl_cuda_kernel_data_t;
+
+typedef struct pocl_cuda_event_data_s
+{
+  CUevent start;
+  CUevent end;
+  volatile int events_ready;
+  cl_int *ext_event_flag;
+  volatile unsigned num_ext_events;
+} pocl_cuda_event_data_t;
+
 extern unsigned int pocl_num_devices;
 
 void *pocl_cuda_submit_thread (void *);
@@ -766,7 +808,7 @@ load_or_generate_kernel (cl_kernel kernel, cl_device_id device,
   if (!pocl_exists (ptx_filename))
     {
       /* Generate PTX from LLVM bitcode */
-      if (pocl_ptx_gen (bc_filename, ptx_filename, kdata, kernel->name,
+      if (pocl_ptx_gen (bc_filename, ptx_filename, kernel->name,
                         device->llvm_cpu,
                         ((pocl_cuda_device_data_t *)device->data)->libdevice,
                         has_offsets))
@@ -853,7 +895,17 @@ pocl_cuda_submit_kernel (CUstream stream, _cl_command_node *cmd,
 
   unsigned i;
   /* Deal with automatic local allocations */
-  sharedMemBytes = kdata->auto_local_offset;
+  for (i = 0; i < meta->num_locals; ++i)
+    {
+      size_t size = meta->local_sizes[i];
+      size_t align = meta->local_alignments[i];
+
+      /* Pad offset to align memory */
+      if (sharedMemBytes % align)
+        sharedMemBytes += align - (sharedMemBytes % align);
+
+      sharedMemBytes += size;
+    }
 
   CUresult result;
   for (i = 0; i < meta->num_args; i++)
diff --git a/lib/CL/devices/cuda/pocl-ptx-gen.cc b/lib/CL/devices/cuda/pocl-ptx-gen.cc
index e42bf3532..e13811b03 100644
--- a/lib/CL/devices/cuda/pocl-ptx-gen.cc
+++ b/lib/CL/devices/cuda/pocl-ptx-gen.cc
@@ -55,8 +55,7 @@ extern ModulePass *createNVVMReflectPass(const StringMap<int> &Mapping);
 
 static void addKernelAnnotations(llvm::Module *Module, const char *KernelName);
 static void fixConstantMemArgs(llvm::Module *Module, const char *KernelName);
-static void fixLocalMemArgs(llvm::Module *Module, const char *KernelName,
-                            pocl_cuda_kernel_data_t *KernelData);
+static void fixLocalMemArgs(llvm::Module *Module, const char *KernelName);
 static void fixPrintF(llvm::Module *Module);
 static void handleGetWorkDim(llvm::Module *Module, const char *KernelName);
 static void linkLibDevice(llvm::Module *Module, const char *KernelName,
@@ -64,8 +63,8 @@ static void linkLibDevice(llvm::Module *Module, const char *KernelName,
 static void mapLibDeviceCalls(llvm::Module *Module);
 
 int pocl_ptx_gen(const char *BitcodeFilename, const char *PTXFilename,
-                 pocl_cuda_kernel_data_t *KernelData, const char *KernelName,
-                 const char *Arch, const char *LibDevicePath, int HasOffsets) {
+                 const char *KernelName, const char *Arch,
+                 const char *LibDevicePath, int HasOffsets) {
   llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> Buffer =
       llvm::MemoryBuffer::getFile(BitcodeFilename);
   if (!Buffer) {
@@ -85,7 +84,7 @@ int pocl_ptx_gen(const char *BitcodeFilename, const char *PTXFilename,
   // Apply transforms to prepare for lowering to PTX.
   fixPrintF(Module->get());
   fixConstantMemArgs(Module->get(), KernelName);
-  fixLocalMemArgs(Module->get(), KernelName, KernelData);
+  fixLocalMemArgs(Module->get(), KernelName);
   handleGetWorkDim(Module->get(), KernelName);
   addKernelAnnotations(Module->get(), KernelName);
   mapLibDeviceCalls(Module->get());
@@ -595,8 +594,8 @@ void linkLibDevice(llvm::Module *Module, const char *KernelName,
 // instructions to calculate the new pointers from the provided base global
 // variable.
 void convertPtrArgsToOffsets(llvm::Module *Module, const char *KernelName,
-                             unsigned AddrSpace, llvm::GlobalVariable *Base,
-                             pocl_cuda_kernel_data_t *KernelData) {
+                             unsigned AddrSpace, llvm::GlobalVariable *Base)
+{
 
   llvm::LLVMContext &Context = Module->getContext();
 
@@ -663,10 +662,6 @@ void convertPtrArgsToOffsets(llvm::Module *Module, const char *KernelName,
     }
   }
 
-  if (KernelData != NULL) {
-    KernelData->auto_local_offset = ConstOffset;
-  }
-
   // Loop over arguments.
   for (auto &Arg : Function->args()) {
     // Check for local memory pointer.
@@ -764,16 +759,15 @@ void fixConstantMemArgs(llvm::Module *Module, const char *KernelName) {
       llvm::Constant::getNullValue(ByteArrayType), "_constant_memory_region_",
       NULL, llvm::GlobalValue::NotThreadLocal, 4, false);
 
-  convertPtrArgsToOffsets(Module, KernelName, 4, ConstantMemBase, NULL);
+  convertPtrArgsToOffsets(Module, KernelName, 4, ConstantMemBase);
 }
 
 // CUDA doesn't allow multiple local memory arguments or automatic variables, so
 // we have to create a single global variable for local memory allocations, and
 // then manually add offsets to it to get each individual local memory
 // allocation.
-void fixLocalMemArgs(llvm::Module *Module, const char *KernelName,
-                     pocl_cuda_kernel_data_t *KernelData) {
-
+void fixLocalMemArgs(llvm::Module *Module, const char *KernelName)
+{
   // Create global variable for local memory allocations.
   llvm::Type *ByteArrayType =
       llvm::ArrayType::get(llvm::Type::getInt8Ty(Module->getContext()), 0);
@@ -782,7 +776,7 @@ void fixLocalMemArgs(llvm::Module *Module, const char *KernelName,
       "_shared_memory_region_", NULL, llvm::GlobalValue::NotThreadLocal, 3,
       false);
 
-  convertPtrArgsToOffsets(Module, KernelName, 3, SharedMemBase, KernelData);
+  convertPtrArgsToOffsets(Module, KernelName, 3, SharedMemBase);
 }
 
 // Map kernel math functions onto the corresponding CUDA libdevice functions.
diff --git a/lib/CL/devices/cuda/pocl-ptx-gen.h b/lib/CL/devices/cuda/pocl-ptx-gen.h
index 5ed47b794..309abe273 100644
--- a/lib/CL/devices/cuda/pocl-ptx-gen.h
+++ b/lib/CL/devices/cuda/pocl-ptx-gen.h
@@ -25,7 +25,6 @@
 #define POCL_PTX_GEN_H
 
 #include "config.h"
-#include "pocl-cuda-types.h"
 
 #ifdef __cplusplus
 extern "C"
@@ -43,7 +42,7 @@ int findLibDevice(char LibDevicePath[PATH_MAX], const char *Arch);
 /* Generate a PTX file from an LLVM bitcode file. */
 /* Returns zero on success, non-zero on failure. */
 int pocl_ptx_gen (const char *BitcodeFilename, const char *PTXFilename,
-                  pocl_cuda_kernel_data_t *KernelData, const char *KernelName,
+                  const char *KernelName,
                   const char *Arch, const char *LibDevicePath, int HasOffsets);
 
 /* Populate the Alignments array with the required pointer alignments for */
diff --git a/lib/CL/pocl_binary.c b/lib/CL/pocl_binary.c
index 3cd1a664a..4b6900edc 100644
--- a/lib/CL/pocl_binary.c
+++ b/lib/CL/pocl_binary.c
@@ -52,9 +52,10 @@
                           no sense in binary, and whether argument is local
                           is already in cl_kernel_arg_address_qualifier);
                           add has_arg_metadata & kernel attributes */
+/* changes for version 8: added local_alignments after local_sizes */
 
 #define FIRST_SUPPORTED_POCLCC_VERSION 6
-#define POCLCC_VERSION 7
+#define POCLCC_VERSION 8
 
 /* pocl binary structures */
 
@@ -101,6 +102,7 @@ typedef struct pocl_binary_kernel_s
   /* arguments and argument metadata. Note that not everything is stored
    * in the serialized binary */
   size_t *local_sizes;
+  size_t *local_alignments;
 } pocl_binary_kernel;
 
 typedef struct pocl_binary_s
@@ -384,6 +386,8 @@ pocl_binary_serialize_kernel_to_buffer(cl_program program,
     {
       uint64_t temp = meta->local_sizes[i];
       BUFFER_STORE (temp, uint64_t);
+      temp = meta->local_alignments[i];
+      BUFFER_STORE (temp, uint64_t);
     }
 
   uint32_t attrlen = meta->attributes ? strlen (meta->attributes) : 0;
@@ -530,11 +534,20 @@ pocl_binary_deserialize_kernel_from_buffer (pocl_binary *b,
         }
 
       kernel->local_sizes = calloc (kernel->num_locals, sizeof (size_t));
+      if (b->version >=8)
+        {
+          kernel->local_alignments = calloc (kernel->num_locals, sizeof (size_t));
+        }
       for (i = 0; i < kernel->num_locals; i++)
         {
           uint64_t temp;
           BUFFER_READ (temp, uint64_t);
           kernel->local_sizes[i] = temp;
+          if (b->version >=8)
+            {
+              BUFFER_READ (temp, uint64_t);
+              kernel->local_alignments[i] = temp;
+            }
         }
 
       if (b->version >= 7)
@@ -755,6 +768,7 @@ pocl_binary_get_kernels_metadata (cl_program program, unsigned device_i)
       km->num_args = k.num_args;
       km->num_locals = k.num_locals;
       km->local_sizes = k.local_sizes;
+      km->local_alignments = k.local_alignments;
       km->attributes = k.attributes;
       km->has_arg_metadata = k.has_arg_metadata;
       km->name = k.kernel_name;
diff --git a/lib/CL/pocl_cl.h b/lib/CL/pocl_cl.h
index aa39f8c14..a787d43b9 100644
--- a/lib/CL/pocl_cl.h
+++ b/lib/CL/pocl_cl.h
@@ -1047,6 +1047,7 @@ typedef struct pocl_kernel_metadata_s
   cl_uint num_args;
   cl_uint num_locals;
   size_t *local_sizes;
+  size_t *local_alignments;
   char *name;
   char *attributes;
   struct pocl_argument_info *arg_info;
diff --git a/lib/CL/pocl_llvm_metadata.cc b/lib/CL/pocl_llvm_metadata.cc
index 253d93dfd..19a727a92 100644
--- a/lib/CL/pocl_llvm_metadata.cc
+++ b/lib/CL/pocl_llvm_metadata.cc
@@ -530,12 +530,16 @@ int pocl_llvm_get_kernels_metadata(cl_program program, unsigned device_i) {
 
     meta->num_locals = locals.size();
     meta->local_sizes = (size_t*)calloc(locals.size(), sizeof(size_t));
+    meta->local_alignments = (size_t*)calloc(locals.size(), sizeof(size_t));
 
     /* Fill up automatic local arguments. */
     for (unsigned i = 0; i < meta->num_locals; ++i) {
       unsigned auto_local_size =
           TD->getTypeAllocSize(locals[i]->getInitializer()->getType());
+      unsigned auto_local_alignment = TD->getTypeAllocSize(
+            locals[i]->getType()->getPointerElementType());
       meta->local_sizes[i] = auto_local_size;
+      meta->local_alignments[i] = auto_local_alignment;
 
       #ifdef DEBUG_POCL_LLVM_API
           printf("### automatic local %d size %u\n", i, auto_local_size);

From e2310537fb1522d93cb9d43f25753d946b367f7a Mon Sep 17 00:00:00 2001
From: Isuru Fernando <isuruf@gmail.com>
Date: Fri, 29 May 2020 11:57:03 -0500
Subject: [PATCH 2/2] Rename POCLCC_VERSION -> POCL_BINARY_VERSION

---
 lib/CL/pocl_binary.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/lib/CL/pocl_binary.c b/lib/CL/pocl_binary.c
index 4b6900edc..d0de01ce9 100644
--- a/lib/CL/pocl_binary.c
+++ b/lib/CL/pocl_binary.c
@@ -54,8 +54,8 @@
                           add has_arg_metadata & kernel attributes */
 /* changes for version 8: added local_alignments after local_sizes */
 
-#define FIRST_SUPPORTED_POCLCC_VERSION 6
-#define POCLCC_VERSION 8
+#define FIRST_SUPPORTED_POCL_BINARY_VERSION 6
+#define POCL_BINARY_VERSION 8
 
 /* pocl binary structures */
 
@@ -243,11 +243,11 @@ check_binary(cl_device_id device, const unsigned char *binary)
       POCL_MSG_WARN ("File is not a pocl binary\n");
       return NULL;
     }
-  if (b.version < FIRST_SUPPORTED_POCLCC_VERSION)
+  if (b.version < FIRST_SUPPORTED_POCL_BINARY_VERSION)
     {
       POCL_MSG_WARN ("PoclBinary version %i is not supported by "
                      "this pocl (the minimal is: %i)\n",
-                     b.version, FIRST_SUPPORTED_POCLCC_VERSION);
+                     b.version, FIRST_SUPPORTED_POCL_BINARY_VERSION);
       return NULL;
     }
   if (pocl_binary_get_device_id(device) != b.device_id)
@@ -620,7 +620,7 @@ pocl_binary_serialize(cl_program program, unsigned device_i, size_t *size)
   memcpy(buffer, POCLCC_STRING_ID, POCLCC_STRING_ID_LENGTH);
   buffer += POCLCC_STRING_ID_LENGTH;
   BUFFER_STORE(pocl_binary_get_device_id(program->devices[device_i]), uint64_t);
-  BUFFER_STORE(POCLCC_VERSION, uint32_t);
+  BUFFER_STORE(POCL_BINARY_VERSION, uint32_t);
   BUFFER_STORE(num_kernels, uint32_t);
   uint64_t flags = 0;
   if (program->flush_denorms)
